# Redis 应用与原理

****

## 缓存发展史

****

### 缓存经典场景

****

![image-20240108192947119](https://image.itbaima.net/images/40/image-2024010819312618.png)

在没有引入缓存前，为了应对大量流量，一般采用：

- LVS 代理
- Nginx 做负载均衡
- 搭建 Tomcat 集群

这种方式下，随着访问量的增大，响应力越差，逐渐无法满足用户体验。

在引入缓存后：

![image-20240108193930755](https://image.itbaima.net/images/40/image-20240108192027523.png)

****

#### 三大经典缓存读写策略

****

旁路缓存模式：Cache Aside Pattern

- 写：先更新`DB`，然后直接删除 `cache`
- 读：从 `cache` 中读取数据，读取到直接返回，否则查 `DB` 后返回，然后将查到的数据写入 `cache`

读写穿透模式：Read/Write Through Pattern

- 写：先查 `cache`，`cache` 中不存在，直接更新 `DB`，否则先更新 `cache`，然后 `cache` 服务更新 `DB`
- 读：从 `cache` 中读取数据，读取到直接返回，否则查 `DB` 后写入到 `cache`，之后返回数据

异步缓存写入：Write Behind Pattern

- 写：写入只更新 `cache`，然后异步批量更新 `DB`
- 读：从 `cache` 中读取数据，读取到直接返回，否则查 `DB` 后写入到 `cache`，之后返回数据

****

#### 双写一致性解决方案

****

以上三种经典的读写策略在一定条件下都会产生缓存和数据库数据不一致的问题，这里给出两种解决方案

**同步方案**：

- 延迟双删：更新数据时先删除缓存，然后修改数据库，延迟一段时间后再次删除缓存
- 延迟一段时间是为了保证数据库集群下的数据同步

**异步方案**：

- 使用消息队列：更改代码加入异步操作缓存的逻辑代码，数据库操作完毕后将要同步的数据发给 mq，mq 的消费者从 mq 获取数据更新缓存
- 使用 canal 组件实现同步：不需要更改业务代码，只需要部署一个 canal 服务，canal 把自己伪装为了 mysql 的从节点，canal 读取 binlog 日志更新缓存

****

### 分布式缓存方案选型

****

分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。

因为，本地缓存只在当前服务里有效，部署两个相同的服务，他们两者之间的本地缓存数据无法共通。

常见的分布式缓存方案为：

- Redis
- Memcache
- Tair

****

#### Redis 和 Memcache 对比

****

**共同点**：

- 都是基于内存的数据库，一般都用来当做缓存使用
- 都有过期策略

**区别**：

- Redis 支持的数据类型更丰富，而 Memcached 只支持最简单的 key-value 数据类型
- Redis 支持数据持久化，有 RDB 和 AOF 两种方案，而 Memcached 没有持久化功能，数据全部存在内存之中
- Redis 原生支持集群模式，Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
- Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持

****

#### Redis 和 Tair 对比

****

**共同点**：

- 都支持数据持久化
- 都有过期策略
- 都支持分布式存储

**区别**：

- Redis 开发语言为 C，Tair 是 C++，
- Redis 支持的数据类型更丰富，而 Tair 主要支持字符串和列表
- Redis 利用主从赋值进行数据备份和同步 ，而 Tair 配置了复制因子的多副本机制，保证数据的可靠性
- 对于数据量大的场景下，Tair 更适用

推荐阅读：[技术选型系列 - Tair&Redis对比](https://cloud.tencent.com/developer/article/1371099)

****

## 数据类型&应用场景

****